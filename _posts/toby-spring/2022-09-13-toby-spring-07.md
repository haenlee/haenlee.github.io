---
title:  "[토비의 스프링] 07. 스프링 핵심 기술의 응용"
excerpt: ""

categories:
  - Toby-Spring
tags:
  - [Spring]

toc: true
toc_sticky: true
 
date: 2022-09-13
last_modified_at: 2022-09-13
---

## 07. 스프링 핵심 기술의 응용
### 목표
- SQL을 DAO에서 분리하기

### JAXB를 이용한 XML 파일 매핑
- JAXB(Java Architecture for XML Binding)을 이용하면 XML파일에 담긴 파일에서 정보를 가져올 수 있다.
- XML문서 정보를 동일한 구조의 오브젝트로 직접 매핑해준다.
- JAXB에서의 언마샬링과 마샬링
    - 언마샬링(Unmarshalling)<br>
    XML 문서를 읽어서 자바의 오브젝트로 변환하는 것
    - 마샬링(Marshalling)<br>
    바인딩 오브젝트를 XML 문서로 변환하는 것

### OXM(Object-XML Mapping)
- XML과 자바 오브젝트를 매핑해서 상화 변환해주는 기술이다.
- OXM기술: Castor XML, JiBX, XmlBeans, XStream
- 기능이 같은 기술이 여러가지 있다면 서비스 추상화를 생각해야 한다.
- 스프링은 Mashaller, Unmarshaller 인터페이스로 OXM 추상화 서비스를 지원한다.

## 7.4 인터페이스 상속을 통한 안전한 기능 확장
### DI를 의식하는 설계
- DI의 가치를 얻으려면 DI에 적합한 오브젝트 설계가 필요하다.
- 적절한 책임과 역할에 따라 오브젝트를 분리하고, 항상 오브젝트는 자유롭게 확장될 수 있다는 점을 염두에 두어야 한다.
- DI는 런타임 시에 의존 오브젝트를 다이내믹하게 연결해줘서 유연한 확장이 목적이기 때문에 항상 확장을 염두해 두고 오브젝트 사이의 관계를 생각해야 한다.

### DI와 인터페이스 프로그래밍
- DI를 적용할 때는 가능한 한 인터페이스를 사용하게 해야한다.
- 다형성을 얻기 위함과 클라이언트와 의존 오브젝트 사이의 관계를 명확하게 해줄 수 있기 때문이다.
- 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
    - 목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 이를 적절하게 분리해줄 필요가 있다.

### 인터페이스 상속
- 하나의 오브젝트가 구현하는 인터페이스를 여러 개 만들어서 구분하는 이유 중의 하나는 오브젝트의 기능이 발정하는 과정에서 다른 종류의 클라이언트가 등장하기 때문이다.
- 때로는 기존 인터페이스를 상속을 통해 확장하는 방법도 사용된다.

## 7.5 DI를 이용해 다양한 구현 방법 적용하기
### ConcurrentHashMap
- HashMap으로는 멀티스레드 환경에서 동시에 수정을 시도하거나 동시에 요청을 하는 경우 예상치 못한 결과가 발생할 수 있다.
- 멀티스레드 환경에서는 ConcurrentHashMap이 권장된다.
- ConcurrentHashMap 은 데이터 조작 시 전체 데이터에 대해 락을 걸지 않고 조회는 락을 사용하지 않는다. 따라서 안전하면서 성능이 보장된다.

### 내장형 데이터베이스 사용
- ConcurrentHashMap은 멀티스레드 환경에서 최소한의 동시성을 보장해주고 성능도 나쁘지 않지만, 저장되는 양이 많다면 내장형 DB를 이용해 안정적인 변경 작업을 하는 것도 좋은 방법이다.
- 내장형 DB는 애플리케이션에 내장돼서 애플리케이션과 함께 시작하고 종료되는 DB다. 데이터는 메모리에 저장되고 IO로 인한 부하가 적어서 성능이 뛰어나다.
- 자바에서 많이 사용되는 내장형 데이터베이스는 H2가 있다.
- 내장형 DB를 사용하는 경우 트랜잭션 적용이 상대적으로 쉽다.(DB 자체가 트랜잭션 기반 작업에 충실하게 설계되었기 때문이다.)

## 7.6 스프링 3.1의 DI
### 자바 언어의 변화와 스프링
- 애노테이션 사용
    - 자바 5에서 등장한 애노테이션은 XML과 같은 외부 설정파일과는 달리 자바 코드의 일부로 사용된다.
    - 코드의 동작에 직접 영향을 주지는 못하지만 메타정보로서 활용되는 데는 XML비해 유리하다.
    - 핵심 로직을 담은 자바 코드, 이를 지원하는 IoC 방식의 프레임워크, 프레임워크와 참조하는 메타정보라는 세 가지로 구성하는 방식에 잘 어울리기 때문에 XML보다 애노테이션의 활용이 늘어났다.
- 정책과 관례를 이용한 프로그래밍
    - 애노테이션을 이용하는 방식은 작성하는 코드의 양에 비해 부가적으로 얻을 수 있는 정보가 많다.
    - 일정한 패턴을 따르는 경우 관례를 부여해 명시적인 설정을 최대한 배제하면 애플리케이션의 코드가 간략해진다.
    - 스프링은 점차 애노테이션으로 메타 정보를 작성하고, 미리 정해진 정책과 관례를 활용한다.
    - 이로써 XML을 전혀 사용하지 않고 스프링 애플리케이션을 만들 수 있다.

### 자바 코드를 이용한 빈 설정
- @Configuration
    - DI 설정 정보를 담은 클래스를 만드려면 자바 클래스에 @Configuration 애노테이션을 붙여주면 된다.
- @Bean
    - @Configuration이 붙은 DI 설정용 클래스에 주로 사용되고 메소드를 이용해서 빈 오브젝트의 생성과 의존관계 주입을 직접 자바 코드로 작성할 수 있게 된다.

### 빈 스캐닝과 자동 와이어링
- @Autowired
    - 자동 와이어링 기법을 이용해서 조건에 맞는 빈을 찾아 자동으로 수정자 메소드나 필드에 넣어준다.
    - 적절히 사용하면 DI 관련 코드를 대폭 줄일 수 있어서 편리하지만, 다른 빈과 의존관계가 어떻게 맺어져 있는지 한눈에 파악하기 힘들다는 단점도 있다.
- @Component
    - 클래스에 부여되며, 해당 클래스는 빈 스캐너를 통해 자동으로 빈에 등록된다.
    - @Component 또는 @Component를 메타 애노테이션으로 갖고 있는 애노테이션이 붙은 클래스가 자동 빈 등록 대상이 된다.
- @ComponentScan
    - 빈 스캔 기능을 사용하겠다는 애노테이션
    - basePackage 값을 설정하여 스캔 범위를 설정할 수 있다.
- @Repository
    - DAO 빈을 자동등록 대상으로 만들 때 사용할 수 있게하는 애노테이션
    - 스프링은 DAO 기능을 제공하는 클래스에는 @Repository 애노테이션을 권장한다.
- @Service
    - 비즈니스 로직을 담고 있는 서비스 계층의 빈을 구분하기 위해 사용되는 애노테이션

### 컨텍스트 분리와 @Import
- 성격이 다르고 변경 이유와 주기가 다른 코드를 분리해서 깔끔하게 만드는 것이 중요하다.
- DI 정보를 담은 빈 설정정보도 마찬가지로 여러 가지 종류가 다른 것들이 있다.
- DI 설정정보를 분리하려면 @Configuration 클래스를 하나 더 추가해서 의도가 다른 설정 코드를 분리하며 된다.
- 자바로 된 설정정보는 @Import 사용해서 가져올 수 있다.
- 하나였던 빈 설정 클래스를 빈의 종류와 적용 환경 등을 고려해 여러 개로 분리 한 뒤, @Import를 사용하면 메인 설정 클래스만으로 설정이 가능하게 할 수 있다.

```java
@Configuration
@Import(SubConfigurationClass.class)
public class MainConfigurationClass { ... }
```

- @Import 적용 예시

### @Profile과 @ActiveProfiles
- @Proifile을 사용하면 환경에 따라 빈 설정정보가 달라져야 하는 경우 애노테이션을 이용해서 간단히 설정정보를 구성할 수 있다.
- 프로파일 설정은 클래스 단위로 지정하고 @Profile 애노테이션을 클래스 레벨에 부여하고 프로파일 이름을 넣어주면 된다.
- @Profile이 붙은 설정 클래스는 @Import로 가져오든 @ContextConfiguration에 직접 명시하던 현재 컨테이너의 활성 프로파일 목록에 해당 클래스의 프로파일 명이 없다면 무시된다.
- @ActiveProfiles 을 이용해서 프로파일을 활성시킬 수 있다.

```java 
@Configuration
@Profile("Test")
public class AppContext { ... }

@ActiveProfiles("Test")
@ContextConfiguration(classes=AppContext.class)
public class ServiceTest { ... }
```

- @Profile과 @ActiveProfiles 예시